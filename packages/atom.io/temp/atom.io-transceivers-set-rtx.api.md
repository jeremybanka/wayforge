## API Report File for "atom.io-transceivers-set-rtx"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EnvironmentData } from 'atom.io/internal';
import { findState } from 'atom.io/ephemeral';
import { Flat as Flat_2 } from 'atom.io';
import { JoinToken } from 'atom.io/data';
import { Json } from 'atom.io/json';
import { JsonInterface } from 'atom.io/json';
import { makeMolecule as makeMolecule_2 } from 'atom.io';
import { MoleculeConstructor as MoleculeConstructor_2 } from 'atom.io';
import { MoleculeCreation as MoleculeCreation_2 } from 'atom.io';
import { MoleculeDisposal as MoleculeDisposal_2 } from 'atom.io';
import { MoleculeFamilyToken as MoleculeFamilyToken_2 } from 'atom.io';
import { MoleculeParams as MoleculeParams_2 } from 'atom.io';
import { MoleculeToken as MoleculeToken_2 } from 'atom.io';
import { MutableAtomFamilyToken as MutableAtomFamilyToken_2 } from 'atom.io';
import { MutableAtomToken as MutableAtomToken_2 } from 'atom.io';
import { ReadableFamilyToken as ReadableFamilyToken_2 } from 'atom.io';
import { ReadableToken as ReadableToken_2 } from 'atom.io';
import { ReadonlySelectorFamilyToken as ReadonlySelectorFamilyToken_2 } from 'atom.io';
import { ReadonlySelectorToken as ReadonlySelectorToken_2 } from 'atom.io';
import { RegularAtomFamilyToken as RegularAtomFamilyToken_2 } from 'atom.io';
import { RegularAtomToken as RegularAtomToken_2 } from 'atom.io';
import { seekState } from 'atom.io/immortal';
import { Store } from 'atom.io/internal';
import { Subject } from 'atom.io/internal';
import { Timeline } from 'atom.io/internal';
import { TimelineAtomUpdate } from 'atom.io/internal';
import { TimelineMoleculeCreation } from 'atom.io/internal';
import { TimelineMoleculeDisposal } from 'atom.io/internal';
import { TimelineSelectorUpdate } from 'atom.io/internal';
import { TimelineStateCreation } from 'atom.io/internal';
import { TimelineStateDisposal } from 'atom.io/internal';
import { TimelineTransactionUpdate } from 'atom.io/internal';
import { TransactorsWithRunAndEnv as TransactorsWithRunAndEnv_2 } from 'atom.io';
import { Transceiver } from 'atom.io/internal';
import { WritableFamilyToken as WritableFamilyToken_2 } from 'atom.io';
import { WritableSelectorFamilyToken as WritableSelectorFamilyToken_2 } from 'atom.io';
import { WritableSelectorToken as WritableSelectorToken_2 } from 'atom.io';
import { WritableToken as WritableToken_2 } from 'atom.io';

// @public (undocumented)
export function atom<T extends Transceiver<any>, J extends Json.Serializable>(options: MutableAtomOptions<T, J>): MutableAtomToken<T, J>;

// @public (undocumented)
export function atom<T>(options: RegularAtomOptions<T>): RegularAtomToken<T>;

// @public (undocumented)
export type AtomEffect<T> = (tools: Effectors<T>) => (() => void) | void;

// @public (undocumented)
export type AtomFamily<T, K extends Json.Serializable = Json.Serializable> = MutableAtomFamily<T extends Transceiver<any> ? T : never, any, K> | RegularAtomFamily<T, K>;

// @public (undocumented)
export function atomFamily<T extends Transceiver<any>, J extends Json.Serializable, K extends Json.Serializable>(options: MutableAtomFamilyOptions<T, J, K>): MutableAtomFamilyTokenWithCall<T, J, K>;

// @public (undocumented)
export function atomFamily<T, K extends Json.Serializable>(options: RegularAtomFamilyOptions<T, K>): RegularAtomFamilyTokenWithCall<T, K>;

// @public (undocumented)
export type AtomFamilyToken<T, K extends Json.Serializable = Json.Serializable> = MutableAtomFamilyToken<T extends Transceiver<any> ? T : never, any, K> | RegularAtomFamilyToken<T, K>;

// @public (undocumented)
export class AtomIOLogger implements Logger {
    constructor(logLevel: `error` | `info` | `warn` | null, filter?: LogFilter | undefined, logger?: Logger);
    // (undocumented)
    error: LogFn;
    // (undocumented)
    info: LogFn;
    // (undocumented)
    logLevel: `error` | `info` | `warn` | null;
    // (undocumented)
    warn: LogFn;
}

// @public (undocumented)
export type AtomOnly<M extends TimelineManageable> = M extends AtomFamilyToken<any, any> ? AtomToken<any> : M extends AtomToken<any> ? M : never;

// @public (undocumented)
export type AtomToken<T> = MutableAtomToken<T extends Transceiver<any> ? T : never, any> | RegularAtomToken<T>;

// @public (undocumented)
export function belongsTo<Family extends RegularAtomFamilyToken_2<any, any>>(family: Family, unknownToken: ReadableToken_2<any>): unknownToken is RegularAtomToken_2<TokenType<Family>>;

// @public (undocumented)
export function belongsTo<Family extends MutableAtomFamilyToken_2<any, any, any>>(family: Family, unknownToken: ReadableToken_2<any>): unknownToken is MutableAtomToken_2<TokenType<Family>, any>;

// @public (undocumented)
export function belongsTo<Family extends WritableSelectorFamilyToken_2<any, any>>(family: Family, unknownToken: ReadableToken_2<any>): unknownToken is WritableSelectorToken_2<TokenType<Family>>;

// @public (undocumented)
export function belongsTo<Family extends ReadonlySelectorFamilyToken_2<any, any>>(family: Family, unknownToken: ReadableToken_2<any>): unknownToken is ReadonlySelectorToken_2<TokenType<Family>>;

// @public (undocumented)
export function belongsTo<Family extends WritableFamilyToken_2<any, any>>(family: Family, unknownToken: ReadableToken_2<any>): unknownToken is WritableToken_2<TokenType<Family>>;

// @public (undocumented)
export function belongsTo<Family extends ReadableFamilyToken_2<any, any>>(family: Family, unknownToken: ReadableToken_2<any>): unknownToken is ReadableToken_2<TokenType<Family>>;

// @public (undocumented)
export function disposeState(token: MoleculeToken<any> | ReadableToken<any>): void;

// @public (undocumented)
export type Effectors<T> = {
    setSelf: <V extends T>(next: V | ((oldValue: T) => V)) => void;
    onSet: (callback: (options: {
        newValue: T;
        oldValue: T;
    }) => void) => void;
};

// @public (undocumented)
export type FamilyMetadata = {
    key: string;
    subKey: string;
};

// @public (undocumented)
export type Flat<R extends {
    [K in PropertyKey]: any;
}> = {
    [K in keyof R]: R[K];
};

// @public (undocumented)
export type Func = (...parameters: any[]) => any;

// @public (undocumented)
export function getState<T>(token: ReadableToken<T>): T;

// @public (undocumented)
export function isToken<KnownToken extends RegularAtomToken_2<any>>(knownToken: KnownToken, unknownToken: ReadableToken_2<any>): unknownToken is RegularAtomToken_2<TokenType<KnownToken>>;

// @public (undocumented)
export function isToken<KnownToken extends MutableAtomToken_2<any, any>>(knownToken: KnownToken, unknownToken: ReadableToken_2<any>): unknownToken is MutableAtomToken_2<TokenType<KnownToken>, any>;

// @public (undocumented)
export function isToken<KnownToken extends WritableSelectorToken_2<any>>(knownToken: KnownToken, unknownToken: ReadableToken_2<any>): unknownToken is WritableSelectorToken_2<TokenType<KnownToken>>;

// @public (undocumented)
export function isToken<KnownToken extends ReadonlySelectorToken_2<any>>(knownToken: KnownToken, unknownToken: ReadableToken_2<any>): unknownToken is ReadonlySelectorToken_2<TokenType<KnownToken>>;

// @public (undocumented)
export function isToken<KnownToken extends WritableToken_2<any>>(knownToken: KnownToken, unknownToken: ReadableToken_2<any>): unknownToken is WritableToken_2<TokenType<KnownToken>>;

// @public (undocumented)
export function isToken<KnownToken extends ReadableToken_2<any>>(knownToken: KnownToken, unknownToken: ReadableToken_2<any>): unknownToken is ReadableToken_2<TokenType<KnownToken>>;

// @public (undocumented)
export type KeyedStateUpdate<T> = Flat<StateUpdate<T> & {
    key: string;
    type: `atom_update` | `selector_update`;
    family?: FamilyMetadata;
}>;

// @public (undocumented)
export const LOG_LEVELS: readonly ["info", "warn", "error"];

// @public (undocumented)
export type LogFilter = (...params: Parameters<LogFn>) => boolean;

// @public (undocumented)
export type LogFn = (icon: LoggerIcon, denomination: TokenDenomination, tokenKey: string, message: string, ...rest: unknown[]) => void;

// @public (undocumented)
export type Logger = Record<LogLevel, LogFn>;

// Warning: (ae-forgotten-export) The symbol "LoggerIconDictionary" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type LoggerIcon = keyof typeof LoggerIconDictionary;

// @public (undocumented)
export type LogLevel = (typeof LOG_LEVELS)[number];

// @public (undocumented)
export function makeMolecule<M extends MoleculeConstructor>(context: MoleculeToken<any> | MoleculeToken<any>[], family: MoleculeFamilyToken<M>, key: MoleculeKey<M>, ...params: MoleculeParams<M>): MoleculeToken<M>;

// @public (undocumented)
export function makeRootMolecule(key: string, store?: Store): MoleculeToken<ObjectConstructor>;

// @public (undocumented)
export type MK<M extends MoleculeConstructor> = MoleculeKey<M>;

// @public (undocumented)
export type MoleculeConstructor = new (transactors: MoleculeTransactors<any>, key: Json.Serializable, ...params: any) => any;

// @public (undocumented)
export type MoleculeCreation<M extends MoleculeConstructor_2> = {
    type: `molecule_creation`;
    token: MoleculeToken_2<M>;
    family: MoleculeFamilyToken_2<M>;
    context: MoleculeToken_2<any>[];
    params: MoleculeParams_2<M>;
};

// @public (undocumented)
export type MoleculeDisposal = {
    type: `molecule_disposal`;
    token: MoleculeToken_2<any>;
    family: MoleculeFamilyToken_2<any>;
    context: MoleculeToken_2<any>[];
    familyKeys: string[];
};

// @public (undocumented)
export type MoleculeFamily<M extends MoleculeConstructor> = Flat_2<MoleculeFamilyToken<M> & {
    subject: Subject<MoleculeCreation_2<M> | MoleculeDisposal_2>;
    dependsOn: `all` | `any`;
    new: M;
}>;

// @public (undocumented)
export function moleculeFamily<M extends MoleculeConstructor>(options: MoleculeFamilyOptions<M>): MoleculeFamilyToken<M>;

// @public (undocumented)
export type MoleculeFamilyOptions<M extends MoleculeConstructor> = {
    key: string;
    dependsOn?: `all` | `any`;
    new: M;
};

// @public (undocumented)
export type MoleculeFamilyToken<M extends MoleculeConstructor> = {
    key: string;
    type: `molecule_family`;
    dependsOn: `all` | `any`;
    __M?: M;
};

// @public (undocumented)
export type MoleculeKey<M extends MoleculeConstructor> = InstanceType<M>[`key`];

// Warning: (ae-forgotten-export) The symbol "Tail" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type MoleculeParams<M extends MoleculeConstructor> = Tail<Tail<ConstructorParameters<M>>>;

// @public (undocumented)
export type MoleculeToken<M extends MoleculeConstructor> = {
    key: MK<M>;
    type: `molecule`;
    family?: MoleculeFamilyToken<M>;
    __M?: M;
};

// @public (undocumented)
export type MoleculeTransactors<K extends Json.Serializable> = Flat_2<Omit<TransactorsWithRunAndEnv_2, `find`> & {
    bond<T extends Transceiver<any>, J extends Json.Serializable>(family: MutableAtomFamilyToken_2<T, J, K>): MutableAtomToken_2<T, J>;
    bond<T>(family: RegularAtomFamilyToken_2<T, K>): RegularAtomToken_2<T>;
    bond<T>(family: WritableSelectorFamilyToken_2<T, K>): WritableSelectorToken_2<T>;
    bond<T>(family: ReadonlySelectorFamilyToken_2<T, K>): ReadonlySelectorToken_2<T>;
    bond<T>(family: WritableFamilyToken_2<T, K>): WritableToken_2<T>;
    bond<T>(family: ReadableFamilyToken_2<T, K>): ReadableToken_2<T>;
    join(joinToken: JoinToken<any, any, any, any>): void;
    spawn<Key extends Json.Serializable, Ctor extends MoleculeConstructor>(family: MoleculeFamilyToken<Ctor>, key: Key, ...params: MoleculeParams<Ctor>): MoleculeToken<Ctor>;
}>;

// @public (undocumented)
export type MoleculeType<T extends MoleculeFamilyToken<any>> = T extends MoleculeFamilyToken<infer M> ? M : T extends MoleculeToken<infer M> ? M : never;

// @public (undocumented)
export type MutableAtomFamily<T extends Transceiver<any>, J extends Json.Serializable, K extends Json.Serializable> = JsonInterface<T, J> & MutableAtomFamilyToken<T, J, K> & {
    (key: K): MutableAtomToken<T, J>;
    subject: Subject<StateCreation<MutableAtomToken<T, J>> | StateDisposal<MutableAtomToken<T, J>>>;
    install: (store: Store) => void;
};

// @public (undocumented)
export type MutableAtomFamilyOptions<T extends Transceiver<any>, J extends Json.Serializable, K extends Json.Serializable> = JsonInterface<T, J> & {
    key: string;
    default: (key: K) => T;
    effects?: (key: K) => AtomEffect<T>[];
    mutable: true;
};

// @public (undocumented)
export type MutableAtomFamilyToken<T extends Transceiver<any>, J extends Json.Serializable, K extends Json.Serializable> = {
    key: string;
    type: `mutable_atom_family`;
    __T?: T;
    __J?: J;
    __K?: K;
};

// @public (undocumented)
export type MutableAtomFamilyTokenWithCall<T extends Transceiver<any>, J extends Json.Serializable, K extends Json.Serializable> = MutableAtomFamilyToken<T, J, K> & {
    (key: K): MutableAtomToken<T, J>;
};

// @public (undocumented)
export type MutableAtomOptions<T extends Transceiver<any>, J extends Json.Serializable> = JsonInterface<T, J> & Omit<RegularAtomOptions<T>, `default`> & {
    default: () => T;
    mutable: true;
};

// @public (undocumented)
export type MutableAtomToken<T extends Transceiver<any>, J extends Json.Serializable> = {
    key: string;
    type: `mutable_atom`;
    family?: FamilyMetadata;
    __J?: J;
    __U?: T extends Transceiver<infer Update> ? Update : never;
};

// @public (undocumented)
export type Read<F extends Func> = (transactors: ReadonlyTransactors, ...parameters: Parameters<F>) => ReturnType<F>;

// @public (undocumented)
export type ReadableFamily<T, K extends Json.Serializable> = AtomFamily<T, K> | SelectorFamily<T, K>;

// @public (undocumented)
export type ReadableFamilyToken<T, K extends Json.Serializable> = AtomFamilyToken<T, K> | SelectorFamilyToken<T, K>;

// @public (undocumented)
export type ReadableToken<T> = AtomToken<T> | SelectorToken<T>;

// @public (undocumented)
export type ReadonlySelectorFamily<T, K extends Json.Serializable> = ((key: K) => ReadonlySelectorToken<T>) & {
    key: string;
    type: `readonly_selector_family`;
    subject: Subject<StateCreation<ReadonlySelectorToken<T>> | StateDisposal<ReadonlySelectorToken<T>>>;
    install: (store: Store) => void;
    __T?: T;
    __K?: K;
};

// @public (undocumented)
export type ReadonlySelectorFamilyOptions<T, K extends Json.Serializable> = {
    key: string;
    get: (key: K) => Read<() => T>;
};

// @public (undocumented)
export type ReadonlySelectorFamilyToken<T, K extends Json.Serializable> = {
    key: string;
    type: `readonly_selector_family`;
    __T?: T;
    __K?: K;
};

// @public (undocumented)
export type ReadonlySelectorFamilyTokenWithCall<T, K extends Json.Serializable> = ReadonlySelectorFamilyToken<T, K> & {
    (key: K): ReadonlySelectorToken<T>;
};

// @public (undocumented)
export type ReadonlySelectorOptions<T> = {
    key: string;
    get: Read<() => T>;
};

// @public (undocumented)
export type ReadonlySelectorToken<T> = {
    key: string;
    type: `readonly_selector`;
    family?: FamilyMetadata;
    __T?: T;
};

// @public (undocumented)
export type ReadonlyTransactors = Pick<Transactors, `find` | `get` | `json` | `seek`>;

// @public (undocumented)
export const redo: (tl: TimelineToken<any>) => void;

// @public (undocumented)
export type RegularAtomFamily<T, K extends Json.Serializable> = RegularAtomFamilyToken<T, K> & {
    (key: K): RegularAtomToken<T>;
    subject: Subject<StateCreation<AtomToken<T>> | StateDisposal<AtomToken<T>>>;
    install: (store: Store) => void;
};

// @public (undocumented)
export type RegularAtomFamilyOptions<T, K extends Json.Serializable> = {
    key: string;
    default: T | ((key: K) => T);
    effects?: (key: K) => AtomEffect<T>[];
};

// @public (undocumented)
export type RegularAtomFamilyToken<T, K extends Json.Serializable> = {
    key: string;
    type: `atom_family`;
    __T?: T;
    __K?: K;
};

// @public (undocumented)
export type RegularAtomFamilyTokenWithCall<T, K extends Json.Serializable> = RegularAtomFamilyToken<T, K> & {
    (key: K): RegularAtomToken<T>;
};

// @public (undocumented)
export type RegularAtomOptions<T> = {
    key: string;
    default: T | (() => T);
    effects?: AtomEffect<T>[];
};

// @public (undocumented)
export type RegularAtomToken<T> = {
    key: string;
    type: `atom`;
    family?: FamilyMetadata;
    __T?: T;
};

// @public (undocumented)
export function runTransaction<F extends Func>(token: TransactionToken<F>, id?: string): (...parameters: Parameters<F>) => ReturnType<F>;

// @public (undocumented)
export function selector<T>(options: WritableSelectorOptions<T>): WritableSelectorToken<T>;

// @public (undocumented)
export function selector<T>(options: ReadonlySelectorOptions<T>): ReadonlySelectorToken<T>;

// @public (undocumented)
export type SelectorFamily<T, K extends Json.Serializable> = ReadonlySelectorFamily<T, K> | WritableSelectorFamily<T, K>;

// @public (undocumented)
export function selectorFamily<T, K extends Json.Serializable>(options: WritableSelectorFamilyOptions<T, K>): WritableSelectorFamilyTokenWithCall<T, K>;

// @public (undocumented)
export function selectorFamily<T, K extends Json.Serializable>(options: ReadonlySelectorFamilyOptions<T, K>): ReadonlySelectorFamilyTokenWithCall<T, K>;

// @public (undocumented)
export type SelectorFamilyToken<T, K extends Json.Serializable> = ReadonlySelectorFamilyToken<T, K> | WritableSelectorFamilyToken<T, K>;

// @public (undocumented)
export type SelectorToken<T> = ReadonlySelectorToken<T> | WritableSelectorToken<T>;

// @public (undocumented)
export function setState<T, New extends T>(token: WritableToken<T>, value: New | ((oldValue: T) => New)): void;

// @public (undocumented)
export class Silo {
    constructor(config: Store[`config`], fromStore?: Store | null);
    // (undocumented)
    atom: typeof atom;
    // (undocumented)
    atomFamily: typeof atomFamily;
    // (undocumented)
    findState: typeof findState;
    // (undocumented)
    getState: typeof getState;
    // (undocumented)
    redo: typeof redo;
    // (undocumented)
    selector: typeof selector;
    // (undocumented)
    selectorFamily: typeof selectorFamily;
    // (undocumented)
    setState: typeof setState;
    // (undocumented)
    store: Store;
    // (undocumented)
    subscribe: typeof subscribe;
    // (undocumented)
    timeline: typeof timeline;
    // (undocumented)
    transaction: typeof transaction;
    // (undocumented)
    undo: typeof undo;
}

// @public (undocumented)
export const simpleLog: (logLevel: keyof Logger) => LogFn;

// @public (undocumented)
export const simpleLogger: Logger;

// @public (undocumented)
export type StateCreation<Token extends ReadableToken<any>> = {
    type: `state_creation`;
    token: Token;
};

// @public (undocumented)
export type StateDisposal<Token extends ReadableToken<any>> = {
    type: `state_disposal`;
    token: Token;
    value?: TokenType<Token>;
};

// @public (undocumented)
export type StateUpdate<T> = {
    newValue: T;
    oldValue: T;
};

// @public (undocumented)
export function subscribe<T>(token: ReadableToken<T>, handleUpdate: UpdateHandler<T>, key?: string, store?: Store): () => void;

// @public (undocumented)
export function subscribe<F extends Func>(token: TransactionToken<F>, handleUpdate: TransactionUpdateHandler<F>, key?: string, store?: Store): () => void;

// @public (undocumented)
export function subscribe<M extends TimelineManageable>(token: TimelineToken<M>, handleUpdate: (update: TimelineUpdate<M> | `redo` | `undo`) => void, key?: string, store?: Store): () => void;

// @public (undocumented)
export const timeline: <ManagedAtom extends TimelineManageable>(options: TimelineOptions<ManagedAtom>) => TimelineToken<ManagedAtom>;

// @public (undocumented)
export type TimelineManageable = AtomFamilyToken<any, any> | AtomToken<any>;

// @public (undocumented)
export type TimelineOptions<ManagedAtom extends TimelineManageable> = {
    key: string;
    scope: (ManagedAtom | MoleculeFamilyToken_2<any>)[];
    shouldCapture?: (update: TimelineUpdate<ManagedAtom>, timeline: Timeline<TimelineManageable>) => boolean;
};

// @public (undocumented)
export type TimelineToken<M> = {
    key: string;
    type: `timeline`;
    __M?: M;
};

// @public (undocumented)
export type TimelineUpdate<ManagedAtom extends TimelineManageable> = TimelineAtomUpdate<ManagedAtom> | TimelineMoleculeCreation<any> | TimelineMoleculeDisposal | TimelineSelectorUpdate<ManagedAtom> | TimelineStateCreation<AtomOnly<ManagedAtom>> | TimelineStateDisposal<AtomOnly<ManagedAtom>> | TimelineTransactionUpdate;

// @public (undocumented)
export type TokenDenomination = `atom` | `continuity` | `molecule_family` | `molecule` | `mutable_atom` | `readonly_selector` | `selector` | `state` | `timeline` | `transaction` | `unknown`;

// @public (undocumented)
export type TokenType<Comparison extends ReadableFamilyToken_2<any, any> | ReadableToken_2<any>> = Comparison extends ReadableToken_2<infer RepresentedValue> ? RepresentedValue : Comparison extends ReadableFamilyToken_2<infer RepresentedValue, any> ? RepresentedValue : never;

// @public (undocumented)
export type Transact<F extends Func> = (transactors: TransactorsWithRunAndEnv, ...parameters: Parameters<F>) => ReturnType<F>;

// @public (undocumented)
export function transaction<F extends Func>(options: TransactionOptions<F>): TransactionToken<F>;

// @public (undocumented)
export type TransactionIO<Token extends TransactionToken<any>> = Token extends TransactionToken<infer F> ? F : never;

// @public (undocumented)
export type TransactionOptions<F extends Func> = {
    key: string;
    do: Transact<F>;
};

// @public (undocumented)
export type TransactionToken<F extends Func> = {
    key: string;
    type: `transaction`;
    __F?: F;
};

// @public (undocumented)
export type TransactionUpdate<F extends Func> = {
    type: `transaction_update`;
    key: string;
    id: string;
    epoch: number;
    updates: TransactionUpdateContent[];
    params: Parameters<F>;
    output: ReturnType<F>;
};

// @public (undocumented)
export type TransactionUpdateContent = KeyedStateUpdate<unknown> | MoleculeCreation<any> | MoleculeDisposal | StateCreation<ReadableToken<unknown>> | StateDisposal<ReadableToken<unknown>> | TransactionUpdate<Func>;

// @public (undocumented)
export type TransactionUpdateHandler<F extends Func> = (data: TransactionUpdate<F>) => void;

// @public (undocumented)
export type Transactors = Readonly<{
    get: <S>(state: ReadableToken<S>) => S;
    set: <S, New extends S>(state: WritableToken<S>, newValue: New | ((oldValue: S) => New)) => void;
    find: typeof findState;
    seek: typeof seekState;
    json: <T extends Transceiver<any>, J extends Json.Serializable>(state: MutableAtomToken<T, J>) => WritableSelectorToken<J>;
}>;

// @public (undocumented)
export type TransactorsWithRunAndEnv = Readonly<{
    get: <S>(state: ReadonlySelectorToken<S> | WritableToken<S>) => S;
    set: <S, New extends S>(state: WritableToken<S>, newValue: New | ((oldValue: S) => New)) => void;
    find: typeof findState;
    seek: typeof seekState;
    json: <T extends Transceiver<any>, J extends Json.Serializable>(state: MutableAtomToken<T, J>) => WritableSelectorToken<J>;
    make: typeof makeMolecule_2;
    dispose: typeof disposeState;
    run: typeof runTransaction;
    env: () => EnvironmentData;
}>;

// @public (undocumented)
export const undo: (tl: TimelineToken<any>) => void;

// @public (undocumented)
export type UpdateHandler<T> = (update: StateUpdate<T>) => void;

// @public (undocumented)
export function useMolecule<M extends MoleculeConstructor>(token: MoleculeToken<M>): InstanceType<M> | undefined;

// @public (undocumented)
export function useMoleculeFromStore<M extends MoleculeConstructor>(token: MoleculeToken<M>, store: Store): InstanceType<M> | undefined;

// @public (undocumented)
export type WritableFamily<T, K extends Json.Serializable> = AtomFamily<T, K> | WritableSelectorFamily<T, K>;

// @public (undocumented)
export type WritableFamilyToken<T, K extends Json.Serializable> = AtomFamilyToken<T, K> | WritableSelectorFamilyToken<T, K>;

// @public (undocumented)
export type WritableSelectorFamily<T, K extends Json.Serializable> = WritableSelectorFamilyToken<T, K> & {
    (key: K): WritableSelectorToken<T>;
    subject: Subject<StateCreation<WritableSelectorToken<T>> | StateDisposal<WritableSelectorToken<T>>>;
    install: (store: Store) => void;
};

// @public (undocumented)
export type WritableSelectorFamilyOptions<T, K extends Json.Serializable> = {
    key: string;
    get: (key: K) => Read<() => T>;
    set: (key: K) => Write<(newValue: T) => void>;
};

// @public (undocumented)
export type WritableSelectorFamilyToken<T, K extends Json.Serializable> = {
    key: string;
    type: `selector_family`;
    __T?: T;
    __K?: K;
};

// @public (undocumented)
export type WritableSelectorFamilyTokenWithCall<T, K extends Json.Serializable> = WritableSelectorFamilyToken<T, K> & {
    (key: K): WritableSelectorToken<T>;
};

// @public (undocumented)
export type WritableSelectorOptions<T> = {
    key: string;
    get: Read<() => T>;
    set: Write<(newValue: T) => void>;
};

// @public (undocumented)
export type WritableSelectorToken<T> = {
    key: string;
    type: `selector`;
    family?: FamilyMetadata;
    __T?: T;
};

// @public (undocumented)
export type WritableToken<T> = AtomToken<T> | WritableSelectorToken<T>;

// @public (undocumented)
export type Write<F extends Func> = (transactors: Transactors, ...parameters: Parameters<F>) => ReturnType<F>;

// (No @packageDocumentation comment for this package)

```
