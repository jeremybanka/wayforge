# atom.io

## atom

import DeclareAnAtom from "../../exhibits-wrapped/declare-an-atom.gen"
import AnAtomTokenIsAReference from "../../exhibits-wrapped/an-atom-token-is-a-reference.gen"
import GetAndSetAnAtom from "../../exhibits-wrapped/get-and-set-an-atom.gen"
import SubscribeToAnAtom from "../../exhibits-wrapped/subscribe-to-an-atom.gen"
import SubscribePowersIntegrations from "../../exhibits-wrapped/subscribe-is-the-foundation-of-reactivity.gen"

<DeclareAnAtom />
Imagine an `atom` as a "reactive variable", with a name, a type, and a starting value.

<AnAtomTokenIsAReference />
As you can see, what is returned from `atom` does not contain the value itself.

Instead, it returns an importable, serializable, and replaceable reference to the value.

We call this an `AtomToken`. In this case, an `AtomToken<number>`.

<GetAndSetAnAtom />
An atom's value is accessed with `getState` and `setState`.

TypeScript will discourage you from setting the wrong type of value.

<SubscribeToAnAtom />
Unlike a standard variable, you can `subscribe` to an atom. The callback you pass
to the subscription will be called whenever the atom is set to a new value.

<SubscribePowersIntegrations />
This is an example of the **observer pattern**. Following the observer pattern allows
atom.io to easily integrate with an observer like React. More on this later.

## selector

import DeclareASelector from "../../exhibits-wrapped/declare-a-selector.gen"
import UseASelector from "../../exhibits-wrapped/use-a-selector.gen"

<DeclareASelector />

A selector is also a reactive variable, but its value is derived from other atoms or selectors.

<UseASelector />

## families

Sometimes you need a lot of the same type of atom or selector. The `atomFamily` and `selectorFamily` functions provide a convenient interface for declaring states dynamically.

## transaction

Transactions allow you to batch multiple atom changes into a single update. This is useful for validating a complex set of changes before it is applied to the store.

## timeline

Timelines allow you to track the history of a group of atoms. If these atoms are set, or set as a group by a selector or transaction, the timeline will record the changes. A timeline can be used to undo and redo changes.

## advanced

### mutable

By default, `atom.io` assumes that the values of atoms are immutable data, always to be copied when changed. However, this constant copying can lead to poor performance, and in particular, a lot of work for your engine's garbage collector. Mutable atoms provide a path to optimization through less garbage creation.
