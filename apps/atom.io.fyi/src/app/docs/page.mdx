import DeclareAnAtom from "../../exhibits-wrapped/declare-an-atom.gen"
import AnAtomTokenIsAReference from "../../exhibits-wrapped/an-atom-token-is-a-reference.gen"
import GetAndSetAnAtom from "../../exhibits-wrapped/get-and-set-an-atom.gen"
import SubscribeToAnAtom from "../../exhibits-wrapped/subscribe-to-an-atom.gen"
import SubscribePowersIntegrations from "../../exhibits-wrapped/subscribe-powers-integrations.gen"

# atom.io

## atom

<DeclareAnAtom />

Imagine an `atom` as a "reactive variable", given a name, a type, and a starting value.

<AnAtomTokenIsAReference />

As you can see, what is returned from `atom` does not contain the value itself.

Instead, it is a importable, serializable, and replaceable reference to the value.

We call this an `AtomToken`. In this case, an `AtomToken<number>`.

<GetAndSetAnAtom />

An atom's value is accessed with `getState` and `setState`.

TypeScript will discourage you from setting the wrong type of value.

<SubscribeToAnAtom />

Unlike a standard variable, you can `subscribe` to an atom. The callback you pass to the subscription will be called whenever the atom is set to a new value.

<SubscribePowersIntegrations />

This is called the **observer pattern**. Following the observer pattern allows atom.io to easily integrate with observer like React. More on this later.

## selector

A selector is also a reactive variable, but its value is derived from other atoms or selectors.

## families

Sometimes you need a lot of the same type of atom or selector. The `atomFamily` and `selectorFamily` functions provide a convenient interface for declaring states dynamically.

## transaction

Transactions allow you to batch multiple atom changes into a single update. This is useful for validating a complex set of changes before it is applied to the store.

## timeline

Timelines allow you to track the history of a group of atoms. If these atoms are set, or set as a group by a selector or transaction, the timeline will record the changes. A timeline can be used to undo and redo changes.

## advanced

### mutable

By default, `atom.io` assumes that the values of atoms are immutable data, always to be copied when changed. However, this constant copying can lead to poor performance, and in particular, a lot of work for your engine's garbage collector. Mutable atoms provide a path to optimization through less garbage creation.
