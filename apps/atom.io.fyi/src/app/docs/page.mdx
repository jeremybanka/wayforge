# atom.io

## atom

import DeclareAnAtom from "../../exhibits-wrapped/declare-an-atom.gen"
import AnAtomTokenIsAReference from "../../exhibits-wrapped/an-atom-token-is-a-reference.gen"
import GetAndSetAnAtom from "../../exhibits-wrapped/get-and-set-an-atom.gen"
import SubscribeToAnAtom from "../../exhibits-wrapped/subscribe-to-an-atom.gen"
import SubscribePowersIntegrations from "../../exhibits-wrapped/subscribe-is-the-foundation-of-reactivity.gen"

<DeclareAnAtom />
Imagine an `atom` as a "reactive variable," with a key, a type, and a default value.

<AnAtomTokenIsAReference />
As you can see, what is returned from `atom` does not contain the value itself.

Instead, it returns an importable, serializable, and replaceable reference to the value.

We call this an `AtomToken`. In this case, an `AtomToken<number>`.

<GetAndSetAnAtom />
An atom's value is accessed with `getState` and `setState`.

TypeScript will discourage you from setting the wrong type of value.

<SubscribeToAnAtom />
Unlike a standard variable, you can `subscribe` to an atom. The callback you pass
to the subscription will be called whenever the atom is set to a new value.

<SubscribePowersIntegrations />
This is an example of the **observer pattern**. Following the observer pattern allows
atom.io to easily integrate with an observer like React. More on this later.

## selector

import DeclareASelector from "../../exhibits-wrapped/declare-a-selector.gen"
import UseASelector from "../../exhibits-wrapped/use-a-selector.gen"

<DeclareASelector />

A selector is also a reactive variable, but its value is derived from other atoms or selectors.

<UseASelector />

In this example, we can see that by setting `dividendState` to a new value, the value of `quotientState` is automatically updated.

## families

import DeclareAFamily from "../../exhibits-wrapped/declare-a-family.gen"
import UseAnIndexToTrackFamilyMembers from "../../exhibits-wrapped/use-an-index-to-track-family-members.gen"

Sometimes you need a lot of the same type of atom or selector. The `atomFamily` and `selectorFamily` functions provide a convenient interface for declaring states dynamically.

<DeclareAFamily />

For example, maybe we're making an app with `Point`s laid out in two dimensions.

We might use an `atomFamily` to handle creating state for each node. Or, better yet, we might make two familiesâ€”for each node's x and y coordinates.

Counterintuitively, it is likely a performance win to take the latter approach, because when nodes move, we only need to replace two primitives in the underlying map, rather than a whole object.

This is an important principle in atom.io: **the smaller the state, the better**.

If you want performance, store primitives in your atoms.

<UseAnIndexToTrackFamilyMembers />

In this example, we use a single `atom<string[]>` to track the members of our family.

It is up to you to decide how to track the members of families you create. `atom.io` does not do this, because different sorts of collections have different performance characteristics. There is no one-size-fits-all solution.

Keen readers may realize that collections generally extend `Object`, and that `Object` is **not** primitive. If you use a lot of collections in your store, or your collections change frequently, you may consider using a `mutable` atom for them. More on this in the advanced section.

## transaction

Transactions allow you to batch multiple atom changes into a single update. This is useful for validating a complex set of changes before it is applied to the store.

{/* [CreateAnAtomInAFamilyAndAddItToAnIndex/] */}

{/* [IterateThroughAnIndexChangingTheValueOfSomeAtoms/] */}

{/* [SubscribeToATransaction/] */}

## timeline

Timelines allow you to track the history of a group of atoms. If these atoms are set, or set as a group by a selector or transaction, the timeline will record the changes. A timeline can be used to undo and redo changes.

## advanced

### mutable

By default, `atom.io` assumes that the values of atoms are immutable data, always to be copied when changed. However, this constant copying can lead to poor performance, and in particular, a lot of work for your engine's garbage collector. Mutable atoms provide a path to optimization through less garbage creation.
